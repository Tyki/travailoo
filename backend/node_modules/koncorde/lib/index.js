"use strict";
/*
 * Kuzzle, a backend software, self-hostable and ready to use
 * to power modern apps
 *
 * Copyright 2015-2021 Kuzzle
 * mailto: support AT kuzzle.io
 * website: http://kuzzle.io
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Koncorde = exports.NormalizedFilter = void 0;
const crypto_1 = require("crypto");
const transform_1 = require("./transform");
const engine_1 = require("./engine");
const convertDistance_1 = require("./util/convertDistance");
const convertGeopoint_1 = require("./util/convertGeopoint");
const hash_1 = require("./util/hash");
const Flatten_1 = require("./util/Flatten");
/**
 * Describes a search filter normalized by Koncorde.
 * Returned by Koncorde.normalize(), and usable with Koncorde.store().
 */
class NormalizedFilter {
    constructor(normalized, id, index) {
        this.filter = normalized;
        this.id = id;
        this.index = index;
    }
}
exports.NormalizedFilter = NormalizedFilter;
class Koncorde {
    /**
     * @param {Object} config   */
    constructor(config = null) {
        if (config && (typeof config !== 'object' || Array.isArray(config))) {
            throw new Error('Invalid argument: expected an object');
        }
        this.config = {
            maxConditions: config && config.maxConditions || 50,
            regExpEngine: config && config.regExpEngine || 're2',
            seed: config && config.seed || crypto_1.randomBytes(32),
        };
        if (this.config.regExpEngine !== 're2' && this.config.regExpEngine !== 'js') {
            throw new Error('Invalid configuration value for "regExpEngine". Supported: re2, js');
        }
        if (!(this.config.seed instanceof Buffer) || this.config.seed.length !== 32) {
            throw new Error('Invalid seed: expected a 32 bytes long Buffer');
        }
        if (!Number.isInteger(this.config.maxConditions)
            || this.config.maxConditions < 0) {
            throw new Error('Invalid maxConditions configuration: positive or nul integer expected');
        }
        this.transformer = new transform_1.Transformer(this.config);
        // Indexed engines: the default index is mapped to the null key
        this.engines = new Map([[null, new engine_1.Engine(this.config)]]);
    }
    /**
     * Checks if the provided filter is valid
     *
     * @param {Object} filter
     * @throws {KoncordeParseError}
     */
    validate(filter) {
        this.transformer.check(filter);
    }
    /**
     * Subscribes an unoptimized filter to the real-time engine.
     * Identical to a call to normalize() + store()
     *
     * Returns the filter unique identifier
     *
     * @param {Object} filter
     * @param {String} [index] - Index name
     * @return {String}
     * @throws {KoncordeParseError}
     */
    register(filter, index = null) {
        const normalized = this.normalize(filter, index);
        return this.store(normalized);
    }
    /**
     * Returns an optimized version of the provided filter, with
     * its associated filter unique ID.
     * Does not store anything in the filters structures.
     * The returned object can either be used with store(), or discarded.
     *
     * @param  {Object} filter
     * @param  {String} [index] name
     * @return {NormalizedFilter}
     * @throws {KoncordeParseError}
     */
    normalize(filter, index = null) {
        if (index !== null && typeof index !== 'string') {
            throw new Error('Invalid "index" argument: must be a string');
        }
        const normalized = this.transformer.normalize(filter);
        const id = hash_1.hash(this.config.seed, { filter: normalized, index });
        return new NormalizedFilter(normalized, id, index);
    }
    /**
     * Stores a normalized filter.
     * A normalized filter is obtained using a call to normalize()
     *
     * Returns the filter unique identifer
     *
     * @param  {NormalizedFilter} normalized - Obtained with a call to normalize()
     * @return {String}
     */
    store(normalized) {
        if (!(normalized instanceof NormalizedFilter)) {
            throw new Error('Invalid argument: not a normalized filter (use Koncorde.normalize to get one)');
        }
        let engine = this.engines.get(normalized.index);
        if (!engine) {
            engine = new engine_1.Engine(this.config);
            this.engines.set(normalized.index, engine);
        }
        engine.store(normalized);
        return normalized.id;
    }
    /**
     * Returns all indexed filter IDs
     *
     * @param {String} [index] name
     * @returns {Array.<String>} Array of matching filter IDs
     */
    getFilterIds(index = null) {
        const engine = this.engines.get(index);
        if (!engine) {
            return [];
        }
        return Array.from(engine.filters.keys());
    }
    /**
     * Returns the list of named indexes
     *
     * @return {Array.<String>}
     */
    getIndexes() {
        return Array.from(this.engines.keys()).map(i => i || '(default)');
    }
    /**
     * Check if a filter identifier is known by Koncorde
     *
     * @param {String} filterId
     * @param {String} [index] name
     * @returns {Boolean}
     */
    hasFilterId(filterId, index = null) {
        const engine = this.engines.get(index);
        return engine && engine.filters.has(filterId);
    }
    /**
     * Test data against filters in the filters tree to get the matching
     * filters ID, if any
     *
     * @param {Object} data to test filters on
     * @param {String} [index] name
     * @return {Array} list of matching filters
     */
    test(data, index = null) {
        const engine = this.engines.get(index);
        if (!engine) {
            return [];
        }
        return engine.match(Flatten_1.flattenObject(data));
    }
    /**
     * Removes all references to a given filter from the real-time engine
     *
     * @param {String} filterId - ID of the filter to remove
     * @param {String} [index] name
     */
    remove(filterId, index = null) {
        const engine = this.engines.get(index);
        if (!engine) {
            return;
        }
        const remaining = engine.remove(filterId);
        if (index && remaining === 0) {
            this.engines.delete(index);
        }
    }
    /**
     * Converts a distance string value to a number of meters
     * @param {string} distance - client-provided distance
     * @returns {number} converted distance
     */
    static convertDistance(distance) {
        return convertDistance_1.convertDistance(distance);
    }
    /**
     * Converts one of the accepted geopoint format into
     * a standardized version
     *
     * @param {Object} obj - object containing a geopoint
     * @returns {Coordinate} or null if no accepted format is found
     */
    static convertGeopoint(point) {
        return convertGeopoint_1.convertGeopoint(point);
    }
}
exports.Koncorde = Koncorde;
//# sourceMappingURL=index.js.map