"use strict";
/*
 * Kuzzle, a backend software, self-hostable and ready to use
 * to power modern apps
 *
 * Copyright 2015-2022 Kuzzle
 * mailto: support AT kuzzle.io
 * website: http://kuzzle.io
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClusterIdCardHandler = exports.IdCard = void 0;
const name_generator_1 = require("../util/name-generator");
const child_process_1 = require("child_process");
const bluebird_1 = __importDefault(require("bluebird"));
require("../types");
const REDIS_PREFIX = "{cluster/node}/";
const REDIS_ID_CARDS_INDEX = REDIS_PREFIX + "id-cards-index";
class IdCard {
    constructor({ id, ip, birthdate, topology }) {
        this.id = id;
        this.ip = ip;
        this.birthdate = birthdate;
        this.topology = new Set(topology);
    }
    serialize() {
        return {
            birthdate: this.birthdate,
            id: this.id,
            ip: this.ip,
            topology: Array.from(this.topology),
        };
    }
    static unserialize(serialized) {
        return new IdCard(serialized);
    }
}
exports.IdCard = IdCard;
/**
 * Handles the ID Key stored in Redis, holding node information
 */
class ClusterIdCardHandler {
    constructor(node) {
        /**
         * Local node ID Card
         */
        this.idCard = null;
        /**
         * Multiplier used to ensure the node has enough time to refresh it's ID Card
         * before the ID Card refresh delay
         */
        this.refreshMultiplier = 2;
        /**
         * Worker thread in charge of refreshing the ID Card once the node has started
         */
        this.refreshWorker = null;
        /**
         * Hold the timer in charge of refreshing the ID Card before the worker starts
         */
        this.refreshTimer = null;
        /**
         * Local node ID
         */
        this.nodeId = null;
        /**
         * Local node Redis key
         */
        this.nodeIdKey = null;
        /**
         * Flag to prevent updating the id card if it has been disposed.
         * Prevents race condition if a topology update occurs at the same time as
         * the id card is been disposed because the node is evicting itself from the
         * cluster
         */
        this.disposed = false;
        this.node = node;
        this.ip = node.ip;
        this.refreshDelay = node.heartbeatDelay;
    }
    /**
     * Generates and reserves a unique ID for this node instance.
     * Makes sure that the ID is not already taken by another node instance.
     */
    async createIdCard() {
        let reserved = false;
        do {
            this.nodeId = name_generator_1.NameGenerator.generateRandomName({ prefix: "knode" });
            this.nodeIdKey = `${REDIS_PREFIX}${this.nodeId}`;
            this.idCard = new IdCard({
                birthdate: Date.now(),
                id: this.nodeId,
                ip: this.ip,
                topology: [],
            });
            reserved = await this.save({ creation: true });
        } while (!reserved);
        await this.addIdCardToIndex();
        this.refreshWorker = this.constructWorker(`${__dirname}/workers/IDCardRenewer.js`);
        this.refreshWorker.on("message", async (message) => {
            if (message.error) {
                await this.node.evictSelf(message.error);
            }
        });
        this.refreshWorker.on("close", async () => {
            if (!this.disposed) {
                this.disposed = true;
                await this.node.evictSelf("ID Card renewer worker closed unexpectedly");
            }
        });
        // Transfer informations to the worker
        this.refreshWorker.send({
            action: "start",
            kuzzle: {
                config: global.kuzzle.config,
                id: global.kuzzle.id,
            },
            nodeIdKey: this.nodeIdKey,
            // Used to configure a redis the same way as the Cache Engine does
            redis: {
                config: global.kuzzle.config.services.internalCache,
                name: "internal_adapter",
            },
            refreshDelay: this.refreshDelay,
            refreshMultiplier: this.refreshMultiplier,
        });
        this.startTemporaryRefresh();
    }
    /**
     * Helper method to mock worker instantiation in unit tests
     */
    constructWorker(path) {
        const childProcess = (0, child_process_1.fork)(path);
        const exitHandler = () => {
            if (!childProcess.killed || childProcess.connected) {
                try {
                    childProcess.disconnect();
                }
                catch (e) {
                    // It could happens that the worker has been killed before the dispose causing disconnect to fail
                }
            }
            process.exit();
        };
        process.on("exit", exitHandler);
        process.on("SIGINT", exitHandler);
        process.on("SIGTERM", exitHandler);
        return childProcess;
    }
    /**
     * Start refreshing the ID Card before the worker starts to ensure the ID Card
     * is refreshed.
     *
     * Once the worker starts, this timer will be stopped.
     */
    startTemporaryRefresh() {
        this.refreshTimer = setInterval(async () => {
            try {
                await this.save();
            }
            catch (error) {
                global.kuzzle.log.error(`An error occurred while refreshing the ID card during WorkerThread startup: ${error}`);
            }
        }, this.refreshDelay * this.refreshMultiplier);
        this.refreshWorker.on("message", ({ initialized }) => {
            if (initialized) {
                clearInterval(this.refreshTimer);
                this.refreshTimer = null;
            }
        });
    }
    async dispose() {
        if (this.disposed) {
            return;
        }
        this.disposed = true;
        if (this.refreshWorker &&
            this.refreshWorker.connected &&
            !this.refreshWorker.killed &&
            this.refreshWorker.channel) {
            try {
                this.refreshWorker.send({ action: "dispose" });
            }
            catch (e) {
                // It could happens that the worker has been killed before the dispose causing send to fail
            }
        }
    }
    /**
     * Retrieves the ID cards from other nodes
     *
     * Each node store it's ID Card under a specific key name. When Redis database
     * is growing, searching for those keys can be quite expensive and can slow down
     * the handshake process.
     *
     * We are storing a set containing ID Card's keys under a set so when a new node
     * is started, it can directly get the other nodes ID Cards with SMEMBERS and
     * then MGET instead of using SCAN.
     *
     * When a new node retrieve the ID Card's keys from the set, it try to get them
     * with MGET, those who cannot be retrieved are expired ID Cards so the node update
     * the set accordingly.
     *
     * @return {Array.<IdCard>}
     */
    async getRemoteIdCards() {
        const idCards = [];
        let keys = await global.kuzzle.ask("core:cache:internal:execute", "smembers", REDIS_ID_CARDS_INDEX);
        keys = keys.filter((nodeIdKey) => nodeIdKey !== this.nodeIdKey);
        if (keys.length === 0) {
            return idCards;
        }
        const rawIdCards = await global.kuzzle.ask("core:cache:internal:mget", keys);
        const expiredIdCards = [];
        for (let i = 0; i < keys.length; i++) {
            // filter keys that might have expired between the key search and their
            // values retrieval
            if (rawIdCards[i] !== null) {
                idCards.push(IdCard.unserialize(JSON.parse(rawIdCards[i])));
            }
            else {
                expiredIdCards.push(keys[i]);
            }
        }
        // Clean expired ID Card's keys in the index
        await bluebird_1.default.map(expiredIdCards, (idCardKey) => {
            return global.kuzzle.ask("core:cache:internal:execute", "srem", REDIS_ID_CARDS_INDEX, idCardKey);
        });
        return idCards;
    }
    /**
     * Adds a remote node IdCard to the node known topology
     */
    async addNode(id) {
        if (this.disposed || this.idCard.topology.has(id)) {
            return;
        }
        this.idCard.topology.add(id);
        await this.save();
    }
    /**
     * Removes a remote node IdCard from the node known topology
     */
    async removeNode(id) {
        if (!this.disposed && this.idCard.topology.delete(id)) {
            await this.save();
        }
    }
    /**
     * Store the key under which this node ID Card is stored inside the set.
     *
     * This set is an index to retrieve ID Cards faster.
     */
    async addIdCardToIndex() {
        await global.kuzzle.ask("core:cache:internal:execute", "sadd", REDIS_ID_CARDS_INDEX, this.nodeIdKey);
    }
    /**
     * Saves the local node IdCard into Redis
     *
     * @returns True if the key was set
     */
    async save({ creation } = { creation: false }) {
        if (!this.idCard) {
            return false;
        }
        return await global.kuzzle.ask("core:cache:internal:store", this.nodeIdKey, JSON.stringify(this.idCard.serialize()), { onlyIfNew: creation, ttl: this.refreshDelay * this.refreshMultiplier });
    }
}
exports.ClusterIdCardHandler = ClusterIdCardHandler;
//# sourceMappingURL=idCardHandler.js.map