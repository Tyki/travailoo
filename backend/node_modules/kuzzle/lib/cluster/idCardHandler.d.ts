import "../types";
export type SerializedIdCard = {
    id: string;
    ip: string;
    birthdate: number;
    topology: string[];
};
export declare class IdCard {
    /**
     * Node unique identifier
     *
     * @example
     *
     * knode-pensive-einstein-844221
     */
    private id;
    /**
     * Node IP address
     */
    private ip;
    /**
     * Node creation timestamp
     */
    private birthdate;
    /**
     * Node known topology composed of node IDs
     *
     * Set<node-id>
     */
    topology: Set<string>;
    constructor({ id, ip, birthdate, topology }: SerializedIdCard);
    serialize(): SerializedIdCard;
    static unserialize(serialized: SerializedIdCard): IdCard;
}
/**
 * Handles the ID Key stored in Redis, holding node information
 */
export declare class ClusterIdCardHandler {
    /**
     * Node instance. Represents the local node.
     */
    private node;
    /**
     * Local node ID Card
     */
    private idCard;
    /**
     * Local node IP address
     */
    private ip;
    /**
     * Delay for refreshing the ID Card. The heartbeat timer is run on this delay
     * and the node ID Card should be available on Redis otherwise it will be evicted.
     */
    private refreshDelay;
    /**
     * Multiplier used to ensure the node has enough time to refresh it's ID Card
     * before the ID Card refresh delay
     */
    private refreshMultiplier;
    /**
     * Worker thread in charge of refreshing the ID Card once the node has started
     */
    private refreshWorker;
    /**
     * Hold the timer in charge of refreshing the ID Card before the worker starts
     */
    private refreshTimer;
    /**
     * Local node ID
     */
    private nodeId;
    /**
     * Local node Redis key
     */
    private nodeIdKey;
    /**
     * Flag to prevent updating the id card if it has been disposed.
     * Prevents race condition if a topology update occurs at the same time as
     * the id card is been disposed because the node is evicting itself from the
     * cluster
     */
    private disposed;
    constructor(node: any);
    /**
     * Generates and reserves a unique ID for this node instance.
     * Makes sure that the ID is not already taken by another node instance.
     */
    createIdCard(): Promise<void>;
    /**
     * Helper method to mock worker instantiation in unit tests
     */
    private constructWorker;
    /**
     * Start refreshing the ID Card before the worker starts to ensure the ID Card
     * is refreshed.
     *
     * Once the worker starts, this timer will be stopped.
     */
    private startTemporaryRefresh;
    dispose(): Promise<void>;
    /**
     * Retrieves the ID cards from other nodes
     *
     * Each node store it's ID Card under a specific key name. When Redis database
     * is growing, searching for those keys can be quite expensive and can slow down
     * the handshake process.
     *
     * We are storing a set containing ID Card's keys under a set so when a new node
     * is started, it can directly get the other nodes ID Cards with SMEMBERS and
     * then MGET instead of using SCAN.
     *
     * When a new node retrieve the ID Card's keys from the set, it try to get them
     * with MGET, those who cannot be retrieved are expired ID Cards so the node update
     * the set accordingly.
     *
     * @return {Array.<IdCard>}
     */
    getRemoteIdCards(): Promise<IdCard[]>;
    /**
     * Adds a remote node IdCard to the node known topology
     */
    addNode(id: string): Promise<void>;
    /**
     * Removes a remote node IdCard from the node known topology
     */
    removeNode(id: string): Promise<void>;
    /**
     * Store the key under which this node ID Card is stored inside the set.
     *
     * This set is an index to retrieve ID Cards faster.
     */
    addIdCardToIndex(): Promise<void>;
    /**
     * Saves the local node IdCard into Redis
     *
     * @returns True if the key was set
     */
    private save;
}
