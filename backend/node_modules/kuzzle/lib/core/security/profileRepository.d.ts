/// <reference types="lodash" />
import { Profile } from "../../model/security/profile";
import { Repository } from "../shared/repository";
import { JSONObject } from "kuzzle-sdk";
/** @internal */
type CreateOrReplaceOptions = {
    method?: string;
    refresh?: string;
    strict?: boolean;
    userId?: string;
};
/** @internal */
type ValidateAndSaveProfileOptions = {
    method?: string;
    refresh?: string;
    strict?: boolean;
    retryOnConflict?: number;
};
/** @internal */
type UpdateOptions = {
    userId?: string;
    refresh?: string;
    strict?: boolean;
    retryOnConflict?: number;
};
/**
 * @class ProfileRepository
 * @extends Repository
 */
export declare class ProfileRepository extends Repository<Profile> {
    private module;
    private profiles;
    /**
     * @constructor
     */
    constructor(securityModule: any);
    init(): void;
    /**
     * Loads a Profile
     *
     * @param {string} id
     * @returns {Promise.<Promise>}
     * @throws {NotFoundError} If the corresponding profile doesn't exist
     */
    load(id: string): Promise<Profile>;
    /**
     * Loads a Profile object given its id.
     * Stores the promise of the profile being loaded in the memcache
     * and then replaces it by the profile itself once it has been loaded
     *
     * This is to allow parallelisation while preventing sending requests
     * to ES, which is slow
     *
     * @param {Array} profileIds - Array of profiles ids
     * @param {Object} options - resetCache (false)
     *
     * @returns {Promise} Resolves to the matching Profile object if found, null
     * if not.
     */
    loadProfiles(profileIds?: string[]): Promise<Profile[]>;
    /**
     * @override
     */
    loadOneFromDatabase(id: string): Promise<Profile>;
    /**
     * Creates a new profile, or create/replace a profile
     *
     * @param {String} id
     * @param {Object} policies
     * @param {Object} [opts]
     * @returns {Profile}
     */
    _createOrReplace(id: string, content: JSONObject, { method, refresh, strict, userId, }?: CreateOrReplaceOptions): Promise<Profile>;
    /**
     * Creates a new profile
     *
     * @param {String} id
     * @param {Object} content
     * @param {Object} [opts]
     * @returns {Profile}
     */
    create(id: string, content: JSONObject, opts?: JSONObject): Promise<Profile>;
    /**
     * Creates or replaces a profile
     *
     * @param {String} id
     * @param {Object} content
     * @param {Object} [opts]
     * @returns {Profile}
     */
    createOrReplace(id: string, content: JSONObject, opts?: JSONObject): Promise<Profile>;
    /**
     * Updates a profile
     * @param  {String} id
     * @param  {Object} content
     * @param  {Object} [opts]
     * @returns {Promise}
     */
    update(id: string, content: JSONObject, { refresh, retryOnConflict, strict, userId }?: UpdateOptions): Promise<Profile>;
    /**
     * Deletes a profile
     *
     * @param {String} id
     * @param {object} [options]
     * @returns {Promise}
     */
    deleteById(id: string, options?: JSONObject): Promise<void>;
    /**
     * @override
     */
    delete(profile: Profile, { refresh, onAssignedUsers, userId }?: {
        refresh?: string;
        onAssignedUsers?: string;
        userId?: string;
    }): Promise<void>;
    /**
     * From a Profile object, returns a serialized object ready to be persisted
     * to the database.
     *
     * @param {Profile} profile
     * @returns {object}
     */
    serializeToDatabase(profile: Profile): import("lodash").Omit<Profile, "_id">;
    /**
     * Given a Profile object, validates its definition and if OK, persist it to the database.
     *
     * @param {Profile} profile
     * @param {Object} [options]
     * @param {string} [options.method] - Document persistence method
     * @param {string} [options.refresh] - (Don't) wait for index refresh
     * @param {number} [options.retryOnConflict] - Number of retries when an
     *                                             update fails due to a conflict
     * @param {boolean} [options.strict] - if true, restrictions can only be
     *                                     applied on existing indexes/collections
     * @returns {Promise<Profile>}
     **/
    validateAndSaveProfile(profile: Profile, { method, refresh, retryOnConflict, strict, }?: ValidateAndSaveProfileOptions): Promise<Profile>;
    /**
     * @param {object} dto
     * @returns {Promise<Profile>}
     */
    fromDTO(dto: JSONObject): Promise<Profile>;
    /**
     * @override
     */
    truncate(opts: JSONObject): Promise<void>;
    /**
     * Invalidate the cache entries for the given profile. If none is provided,
     * the entire cache is emptied.
     * @param {string} [profileId]
     */
    invalidate(profileId?: string): void;
    /**
     * Optimize each policy to get a O(1) index access time
     * and a O(log(n)) collection search time.
     *
     * - Deduplicate indexes using a map
     * - Sort collections per index
     * @param {Object[]} policies
     */
    private optimizePolicies;
    /**
     * Optimize a policy to get a O(1) index access time
     * and a O(log(n)) collection search time.
     *
     * - Deduplicate indexes using a map
     * - Sort collections per index
     * @param policy
     */
    private optimizePolicy;
    toDTO(dto: Profile): Promise<JSONObject>;
    deleteFromDatabase(id: string, options: JSONObject): Promise<any>;
    search(searchBody: JSONObject, options: JSONObject): Promise<{
        aggregations: any;
        hits: any[];
        scrollId: any;
        total: any;
    }>;
    scroll(id: string, ttl: number): Promise<{
        aggregations: any;
        hits: any[];
        scrollId: any;
        total: any;
    }>;
}
export {};
