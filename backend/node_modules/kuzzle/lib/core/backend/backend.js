"use strict";
/*
 * Kuzzle, a backend software, self-hostable and ready to use
 * to power modern apps
 *
 * Copyright 2015-2022 Kuzzle
 * mailto: support AT kuzzle.io
 * website: http://kuzzle.io
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Backend = void 0;
const fs_1 = __importDefault(require("fs"));
const kuzzle_1 = __importDefault(require("../../kuzzle"));
const embeddedSdk_1 = require("../shared/sdk/embeddedSdk");
const kerror = __importStar(require("../../kerror"));
const index_1 = require("../../../index");
const index_2 = require("./index");
const assertionError = kerror.wrap("plugin", "assert");
const runtimeError = kerror.wrap("plugin", "runtime");
let _app = null;
Reflect.defineProperty(global, "app", {
    configurable: true,
    enumerable: false,
    get() {
        if (_app === null) {
            throw new Error("App instance not found. Are you sure you have already started your application?");
        }
        return _app;
    },
    set(value) {
        if (_app !== null) {
            throw new Error("Cannot build an App instance: another one already exists");
        }
        _app = value;
    },
});
class Backend {
    /**
     * Instantiates a new Kuzzle application
     *
     * @param name - Your application name
     */
    constructor(name) {
        this.started = false;
        this._pipes = {};
        this._hooks = {};
        this._controllers = {};
        this._plugins = {};
        this._import = {
            mappings: {},
            onExistingUsers: "skip",
            profiles: {},
            roles: {},
            userMappings: {},
            users: {},
        };
        this._installationsWaitingList = [];
        /**
         * Current Git commit (if available)
         */
        this.commit = null;
        /**
         * @deprecated
         *
         * Use the app.import.xxx() feature instead.
         *
         * Support for old features available before Kuzzle as a framework
         * to avoid breaking existing deployments.
         *
         */
        this._support = {};
        /**
         * Requiring the PluginObject on module top level creates cyclic dependency
         */
        Reflect.defineProperty(this, "PluginObject", {
            value: require("../plugin/plugin"),
        });
        if (!this.PluginObject.checkName(name)) {
            throw assertionError.get("invalid_application_name", name);
        }
        this._name = name;
        Reflect.defineProperty(this, "_kuzzle", {
            writable: true,
        });
        Reflect.defineProperty(this, "_sdk", {
            writable: true,
        });
        /**
         * Set the "started" property in this event so developers can use runtime
         * features in pipes/hooks attached to this event.
         */
        this._pipes["kuzzle:state:ready"] = [
            async () => {
                this.started = true;
            },
        ];
        try {
            const info = JSON.parse(fs_1.default.readFileSync("./package.json", "utf8"));
            this.version = info.version;
        }
        catch (error) {
            // Silent if no version can be found
        }
        global.app = this;
        this.pipe = new index_2.BackendPipe(this);
        this.hook = new index_2.BackendHook(this);
        this.config = new index_2.BackendConfig(this);
        this.vault = new index_2.BackendVault(this);
        this.controller = new index_2.BackendController(this);
        this.plugin = new index_2.BackendPlugin(this);
        this.storage = new index_2.BackendStorage(this);
        this.import = new index_2.BackendImport(this);
        this.log = new index_2.InternalLogger(this);
        this.cluster = new index_2.BackendCluster();
        this.openApi = new index_2.BackendOpenApi(this);
        this.errors = new index_2.BackendErrors(this);
        this.subscription = new index_1.BackendSubscription(this);
        this.kerror = kerror;
        try {
            this.commit = this._readCommit();
        }
        catch {
            // catch errors and leave commit value to "null"
        }
    }
    /**
     * Starts the Kuzzle application with the defined features
     */
    async start() {
        var _a;
        if (this.started) {
            throw runtimeError.get("already_started", "start");
        }
        this._kuzzle = new kuzzle_1.default(this.config.content);
        for (const plugin of this.config.content.plugins.common.include) {
            const { default: PluginClass } = await (_a = plugin, Promise.resolve().then(() => __importStar(require(_a))));
            this.plugin.use(new PluginClass(), {
                deprecationWarning: false,
                name: plugin,
            });
        }
        const application = new this.PluginObject(this._instanceProxy, {
            application: true,
            name: this.name,
        });
        application.version = this.version;
        application.commit = this.commit;
        application.openApi = this.openApi.definition;
        const options = {
            import: this._import,
            installations: this._installationsWaitingList,
            plugins: this._plugins,
            secretsFile: this._secretsFile,
            support: this._support,
            vaultKey: this._vaultKey,
        };
        await this._kuzzle.start(application, options);
        this._sdk = new embeddedSdk_1.EmbeddedSDK();
        this.started = true;
    }
    /**
     * Triggers an event
     *
     * @param - Event name
     * @param - Event payload
     *
     * @returns {Promise<any>}
     */
    trigger(event, ...payload) {
        if (!this.started) {
            throw runtimeError.get("unavailable_before_start", "trigger");
        }
        return this._kuzzle.pipe(event, ...payload);
    }
    /**
     * Register a method that will be executed only once on any given environment.
     * If this method throws, the app won't start.
     *
     * @param {string} id - Unique id needed to differenciate each installation
     * @param {Function} handler - Method to execute only once
     * @param {string | undefined} description - Optional: Describe the purpose of this installation
     *
     */
    install(id, handler, description) {
        if (this.started) {
            throw runtimeError.get("already_started", "install");
        }
        if (typeof id !== "string") {
            throw kerror.get("validation", "assert", "invalid_type", "id", "string");
        }
        if (typeof handler !== "function") {
            throw kerror.get("validation", "assert", "invalid_type", "handler", "function");
        }
        if (description && typeof description !== "string") {
            throw kerror.get("validation", "assert", "invalid_type", "id", "string");
        }
        this._installationsWaitingList.push({ description, handler, id });
    }
    /**
     * Application Name
     */
    get name() {
        return this._name;
    }
    /**
     * EmbeddedSDK instance
     */
    get sdk() {
        if (!this.started) {
            throw runtimeError.get("unavailable_before_start", "sdk");
        }
        return this._sdk;
    }
    /**
     * Cluster node ID
     */
    get nodeId() {
        if (!this.started) {
            throw runtimeError.get("unavailable_before_start", "nodeId");
        }
        return this._kuzzle.id;
    }
    get _instanceProxy() {
        return {
            api: this._controllers,
            hooks: this._hooks,
            // eslint-disable-next-line @typescript-eslint/no-empty-function
            init: () => { },
            pipes: this._pipes,
        };
    }
    /**
     * Try to read the current commit hash.
     */
    _readCommit(dir = process.cwd(), depth = 3) {
        if (depth === 0) {
            return null;
        }
        const gitDir = `${dir}/.git`;
        if (!fs_1.default.existsSync(gitDir) && depth > 0) {
            return this._readCommit(`${dir}/..`, depth - 1);
        }
        if (!fs_1.default.statSync(gitDir).isDirectory()) {
            return null;
        }
        const ref = fs_1.default.readFileSync(`${dir}/.git/HEAD`, "utf8").split("ref: ")[1];
        const refFile = `${dir}/.git/${ref}`.replace("\n", "");
        if (!fs_1.default.existsSync(refFile)) {
            return null;
        }
        return fs_1.default.readFileSync(refFile, "utf8").replace("\n", "");
    }
}
exports.Backend = Backend;
//# sourceMappingURL=backend.js.map