import { KuzzleRequest } from "../../api/request";
import { User, RoomList } from "../../types";
/**
 * The HotelClerk is responsible of keeping the list of rooms and subscriptions
 * made to those rooms.
 *
 * When a subscription is made to a room, the HotelClerk link the connection
 * to a channel of this room. Each channel represents a specific configuration
 * about which kind of notification the subscriber should receive (e.g. scope in/out)
 *
 * When an user is subscribing, we send him back the channel he is subscribing to.
 *
 * Here stop the role of the HotelClerk, then the notifier will select the channels
 * according to the notification and notify them.
 */
export declare class HotelClerk {
    private module;
    /**
     * Number of created rooms.
     *
     * Used with the "subscriptionRooms" configuration limit.
     */
    private roomsCount;
    /**
     * Current realtime rooms.
     *
     * This object is used by the notifier to list wich channel has to be notified
     * when a subscription scope is matching.
     * It's also used to notify channels when an user join/exit a room.
     *
     * Map<roomId, Room>
     */
    private rooms;
    /**
     * Current subscribing connections handled by the HotelClerk.
     *
     * Each connection can subscribe to many rooms with different volatile data.
     *
     * This object is used to keep track of all subscriptions made by a connection
     * to be able to unsubscribe when a connection is removed.
     *
     * Map<connectionId, ConnectionRooms>
     */
    private subscriptions;
    /**
     * Shortcut to the Koncorde instance on the global object.
     */
    private koncorde;
    constructor(realtimeModule: any);
    /**
     * Registers the ask events.
     */
    init(): Promise<void>;
    /**
     * Subscribe a connection to a realtime room.
     *
     * The room will be created if it does not already exists.
     *
     * Notify other subscribers on this room about this new subscription
     *
     * @throws Throws if the user has already subscribed to this room name
     *         (just for rooms with same name, there is no error if the room
     *         has a different name with same filter) or if there is an error
     *         during room creation
     */
    subscribe(request: KuzzleRequest): Promise<{
        channel: string;
        roomId: string;
    }>;
    /**
     * Returns the list of collections of an index with realtime rooms.
     */
    listCollections(index: string): string[];
    /**
     * Joins an existing realtime room.
     *
     * The room may exists on another cluster node, if it's the case, the normalized
     * filters will be fetched from the cluster.
     */
    join(request: KuzzleRequest): Promise<{
        channel: any;
        roomId: any;
    }>;
    /**
     * Return the list of index, collection, rooms and subscribing connections
     * on all index/collection pairs that the requesting user is allowed to
     * subscribe.
     */
    list(user: User): Promise<RoomList>;
    /**
     * Removes a connections and unsubscribe it from every subscribed rooms.
     *
     * Usually called when an user has been disconnected from Kuzzle.
     */
    removeConnection(connectionId: string, notify?: boolean): Promise<void>;
    /**
     * Clear all connections made to this node:
     *   - trigger appropriate core events
     *   - send user exit room notifications
     */
    clearConnections(): Promise<void>;
    /**
     * Register a new subscription
     *  - save the subscription on the provided room with volatile data
     *  - add the connection to the list of active connections of the room
     */
    private registerSubscription;
    /**
     * Create new room if needed
     *
     * @returns {void}
     */
    private createRoom;
    /**
     * Remove a connection from a room.
     *
     * Also delete the rooms if it was the last connection subscribing to it.
     *
     */
    unsubscribe(connectionId: string, roomId: string, notify?: boolean): Promise<void>;
    /**
     * Returns inner metrics from the HotelClerk
     */
    metrics(): {
        rooms: number;
        subscriptions: number;
    };
    /**
     * Deletes a room if no user has subscribed to it, and removes it also from the
     * real-time engine
     */
    private removeRoom;
    /**
     * Subscribes a connection to an existing room.
     *
     * The subscription is made on a configuration channel who will be created
     * on the room if it does not already exists.
     *
     */
    private subscribeToRoom;
    /**
     * Create an empty room in the RAM cache if it doesn't exists
     *
     * @returns True if a new room has been created
     */
    private newRoom;
}
