import { JSONObject } from "kuzzle-sdk";
export declare class Repository<TObject extends {
    _id: string;
}> {
    protected ttl: number;
    protected index: string;
    protected collection: string;
    protected ObjectConstructor: any;
    protected store: any;
    protected cacheDb: any;
    constructor({ cache, store }?: {
        cache?: any;
        store?: any;
    });
    loadOneFromDatabase(id: string): Promise<TObject>;
    loadMultiFromDatabase(ids: string[]): Promise<TObject[]>;
    /**
     * Search in database corresponding repository according to a query
     *
     * @param {object} searchBody
     * @param {object} [options] - optional search arguments (from, size, scroll)
     * @returns {Promise}
     */
    search(searchBody: any, options?: {}): Promise<{
        aggregations: any;
        hits: any[];
        scrollId: any;
        total: any;
    }>;
    /**
     * Scroll over a paginated search request
     */
    scroll(scrollId: string, ttl?: string | number): Promise<{
        aggregations: any;
        hits: any[];
        scrollId: any;
        total: any;
    }>;
    /**
     * Loads an object from Cache. Returns a promise that resolves either to the
     * retrieved object of null in case it is not found.
     *
     * The opts object currently accepts one optional parameter: key, which forces
     * the cache key to fetch.
     * In case the key is not provided, it defaults to repos/<index>/<collection>/<id>, i.e.: repos/%kuzzle/users/12
     *
     * @param id - The id of the object to get
     * @param options.key - Cache key.
     */
    loadFromCache(id: string, options?: {
        key?: string;
    }): Promise<TObject>;
    /**
     * Loads an object from Cache or from the Database if not available in Cache.
     * Returns a promise that resolves either to the
     * retrieved object of null in case it is not found.
     *
     * If the object is not found in Cache and found in the Database,
     * it will be written to cache also.
     *
     * The opts object currently accepts one optional parameter: key, which forces
     * the cache key to fetch.
     * In case the key is not provided, it defaults to <collection>/id
     * (e.g. users/12)
     *
     * @param id - The id of the object to get
     * @param options.key - Optional cache key
     */
    load(id: string, options?: {
        key?: string;
    }): Promise<TObject>;
    /**
     * Persists the given object in the collection that is attached to the repository.
     *
     * @param object - The object to persist
     * @param options.method -
     * @returns {Promise}
     */
    persistToDatabase(object: TObject, options?: any): any;
    /**
     * Given an object with an id, delete it from the configured storage engines
     *
     * @param object - The object to delete
     * @param options.key - if provided, removes the given key instead of the default one (<collection>/<id>)
     */
    delete(object: TObject, options?: any): Promise<void>;
    /**
     * Delete repository from database according to its id
     */
    deleteFromDatabase(id: string, options?: JSONObject): any;
    /**
     * Persists the given ObjectConstructor object in cache.
     *
     * @param object - The object to persist
     * @param options.key - if provided, stores the object to the given key instead of the default one (<collection>/<id>)
     * @param options.ttl - if provided, overrides the default ttl set on the repository for the current operation
     */
    persistToCache(object: TObject, options?: {
        key?: string;
        ttl?: number;
    }): Promise<TObject>;
    /**
     * Removes the object from the Cache Engine
     *
     * @param id
     * @param options.key - if provided, stores the object to the given key instead of the default one (<collection>/<id>)
     */
    deleteFromCache(id: string, options?: {
        key?: string;
    }): Promise<void>;
    /**
     * @param object
     * @param options.key - if provided, stores the object to the given key instead of the default one (<collection>/<id>)
     * @param options.ttl - if provided, overrides the default ttl set on the repository for the current operation
     */
    refreshCacheTTL(object: JSONObject, options?: {
        key?: string;
        ttl?: number;
    }): any;
    /**
     * @param object
     * @param options.key - if provided, stores the object to the given key instead of the default one (<collection>/<id>)
     */
    expireFromCache(object: TObject, options?: {
        key?: string;
    }): Promise<void>;
    /**
     * Serializes the object before being persisted to cache.
     *
     * @param object - The object to serialize
     */
    serializeToCache(object: TObject): any;
    /**
     * Serializes the object before being persisted to the database.
     *
     * @param object - The object to serialize
     */
    serializeToDatabase(object: TObject): Omit<TObject, "_id">;
    /**
     * @param {string} id
     */
    getCacheKey(id: string): string;
    /**
     * @param {object} dto
     * @returns {Promise<ObjectConstructor>}
     */
    fromDTO(dto: JSONObject): Promise<TObject>;
    /**
     * @param {ObjectConstructor} o
     * @returns {object}
     */
    toDTO(o: TObject): any;
    /**
     * Recursively delete all objects in repository with a scroll
     *
     * @param {object} options - ES options (refresh)
     * @param {object} part
     * @returns {Promise<integer>} total deleted objects
     */
    truncate(options: any): Promise<any>;
    /**
     * Do not override this: this function calls itself.
     */
    private _truncate;
    /**
     * @param {Array} objects
     * @param {object} options
     * @returns {Promise<integer>} count of deleted objects
     */
    private truncatePart;
    /**
     * Given a raw search response from ES, returns a {total: int, hits: []} object
     * @param {object} raw
     * @returns {Promise<object>}
     * @private
     */
    private formatSearchResults;
}
