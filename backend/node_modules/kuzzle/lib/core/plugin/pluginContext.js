"use strict";
/*
 * Kuzzle, a backend software, self-hostable and ready to use
 * to power modern apps
 *
 * Copyright 2015-2022 Kuzzle
 * mailto: support AT kuzzle.io
 * website: http://kuzzle.io
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PluginContext = void 0;
const bluebird_1 = __importDefault(require("bluebird"));
const KoncordeWrapper_1 = require("../shared/KoncordeWrapper");
const embeddedSdk_1 = require("../shared/sdk/embeddedSdk");
const pluginRepository_1 = __importDefault(require("./pluginRepository"));
const store_1 = __importDefault(require("../shared/store"));
const elasticsearch_1 = __importDefault(require("../../service/storage/elasticsearch"));
const safeObject_1 = require("../../util/safeObject");
const promback_1 = __importDefault(require("../../util/promback"));
const mutex_1 = require("../../util/mutex");
const kerror = __importStar(require("../../kerror"));
const storeScopeEnum_1 = __importDefault(require("../storage/storeScopeEnum"));
const errors_1 = require("../../kerror/errors");
const index_1 = require("../../../index");
const backend_1 = require("../backend");
const contextError = kerror.wrap("plugin", "context");
class PluginContext {
    constructor(pluginName) {
        this.config = JSON.parse(JSON.stringify(global.kuzzle.config));
        Object.freeze(this.config);
        // @deprecated - backward compatibility only
        this.errors = {
            BadRequestError: errors_1.BadRequestError,
            ExternalServiceError: errors_1.ExternalServiceError,
            ForbiddenError: errors_1.ForbiddenError,
            GatewayTimeoutError: errors_1.GatewayTimeoutError,
            InternalError: errors_1.InternalError,
            KuzzleError: errors_1.KuzzleError,
            NotFoundError: errors_1.NotFoundError,
            PartialError: errors_1.PartialError,
            PluginImplementationError: errors_1.PluginImplementationError,
            PreconditionError: errors_1.PreconditionError,
            ServiceUnavailableError: errors_1.ServiceUnavailableError,
            SizeLimitError: errors_1.SizeLimitError,
            TooManyRequestsError: errors_1.TooManyRequestsError,
            UnauthorizedError: errors_1.UnauthorizedError,
        };
        this.kerror = kerror.wrap("plugin", pluginName);
        // @deprecated - backward compatibility only
        this.errorsManager = this.kerror;
        /* context.secrets ====================================================== */
        this.secrets = JSON.parse(JSON.stringify(global.kuzzle.vault.secrets));
        Object.freeze(this.secrets);
        // uppercase are forbidden by ES
        const pluginIndex = `plugin-${pluginName}`.toLowerCase();
        /* context.constructors =============================================== */
        const pluginStore = new store_1.default(pluginIndex, storeScopeEnum_1.default.PRIVATE);
        // eslint-disable-next-line no-inner-declarations
        function PluginContextRepository(collection, ObjectConstructor = null) {
            if (!collection) {
                throw contextError.get("missing_collection");
            }
            const pluginRepository = new pluginRepository_1.default(pluginStore, collection);
            pluginRepository.init({ ObjectConstructor });
            return {
                create: (...args) => pluginRepository.create(...args),
                createOrReplace: (...args) => pluginRepository.createOrReplace(...args),
                delete: (...args) => pluginRepository.delete(...args),
                get: (...args) => pluginRepository.load(...args),
                mGet: (...args) => pluginRepository.loadMultiFromDatabase(...args),
                replace: (...args) => pluginRepository.replace(...args),
                search: (...args) => pluginRepository.search(...args),
                update: (...args) => pluginRepository.update(...args),
            };
        }
        // eslint-disable-next-line no-inner-declarations
        function PluginContextESClient() {
            return elasticsearch_1.default.buildClient(global.kuzzle.config.services.storageEngine.client);
        }
        this.constructors = {
            BaseValidationType: require("../validation/baseType"),
            ESClient: PluginContextESClient,
            Koncorde: KoncordeWrapper_1.Koncorde,
            Mutex: mutex_1.Mutex,
            Repository: PluginContextRepository,
            Request: instantiateRequest,
            RequestContext: index_1.RequestContext,
            RequestInput: index_1.RequestInput,
        };
        Object.freeze(this.constructors);
        /* context.log ======================================================== */
        this.log = {
            debug: (msg) => global.kuzzle.log.debug(`[${pluginName}] ${msg}`),
            error: (msg) => global.kuzzle.log.error(`[${pluginName}] ${msg}`),
            info: (msg) => global.kuzzle.log.info(`[${pluginName}] ${msg}`),
            silly: (msg) => global.kuzzle.log.silly(`[${pluginName}] ${msg}`),
            verbose: (msg) => global.kuzzle.log.verbose(`[${pluginName}] ${msg}`),
            warn: (msg) => global.kuzzle.log.warn(`[${pluginName}] ${msg}`),
        };
        Object.freeze(this.log);
        /* context.accessors ================================================== */
        this.accessors = {
            cluster: new backend_1.BackendCluster(),
            execute: (request, callback) => execute(request, callback),
            nodeId: global.kuzzle.id,
            sdk: new embeddedSdk_1.EmbeddedSDK(),
            storage: {
                bootstrap: (collections) => pluginStore.init(collections),
                createCollection: (collection, mappings) => pluginStore.createCollection(collection, { mappings }),
            },
            strategies: {
                add: curryAddStrategy(pluginName),
                remove: curryRemoveStrategy(pluginName),
            },
            subscription: {
                register: (connectionId, index, collection, filters) => {
                    const request = new index_1.KuzzleRequest({
                        action: "subscribe",
                        body: filters,
                        collection,
                        controller: "realtime",
                        index,
                    }, {
                        connectionId: connectionId,
                    });
                    return global.kuzzle.ask("core:realtime:subscribe", request);
                },
                unregister: (connectionId, roomId, notify) => global.kuzzle.ask("core:realtime:unsubscribe", connectionId, roomId, notify),
            },
            trigger: (eventName, payload) => global.kuzzle.pipe(`plugin-${pluginName}:${eventName}`, payload),
            validation: {
                addType: global.kuzzle.validation.addType.bind(global.kuzzle.validation),
                validate: global.kuzzle.validation.validate.bind(global.kuzzle.validation),
            },
        };
        // @todo freeze the "accessors" object once we don't have
        // the PriviledgedContext anymore
    }
}
exports.PluginContext = PluginContext;
/**
 * @param {KuzzleRequest} request
 * @param {Function} [callback]
 */
function execute(request, callback) {
    if (callback && typeof callback !== "function") {
        const error = contextError.get("invalid_callback", typeof callback);
        global.kuzzle.log.error(error);
        return bluebird_1.default.reject(error);
    }
    const promback = new promback_1.default(callback);
    if (!request ||
        (!(request instanceof index_1.KuzzleRequest) && !(request instanceof index_1.Request))) {
        return promback.reject(contextError.get("missing_request"));
    }
    if (request.input.controller === "realtime" &&
        ["subscribe", "unsubscribe"].includes(request.input.action)) {
        return promback.reject(contextError.get("unavailable_realtime", request.input.action));
    }
    request.clearError();
    request.status = 102;
    global.kuzzle.funnel
        .executePluginRequest(request)
        .then((result) => {
        request.setResult(result, {
            status: request.status === 102 ? 200 : request.status,
        });
        promback.resolve(request);
    })
        .catch((err) => {
        promback.reject(err);
    });
    return promback.deferred;
}
/**
 * Instantiates a new Request object, using the provided one
 * to set the context informations
 *
 * @throws
 * @param {Request} request
 * @param {Object} data
 * @param {Object} [options]
 * @returns {Request}
 */
function instantiateRequest(request, data, options = {}) {
    let _request = request, _data = data, _options = options;
    if (!_request) {
        throw contextError.get("missing_request_data");
    }
    if (!(_request instanceof index_1.KuzzleRequest)) {
        if (_data) {
            _options = _data;
        }
        _data = _request;
        _request = null;
    }
    else {
        Object.assign(_options, _request.context.toJSON());
    }
    const target = new index_1.KuzzleRequest(_data, _options);
    // forward informations if a request object was supplied
    if (_request) {
        for (const resource of ["_id", "index", "collection"]) {
            if (!target.input.resource[resource]) {
                target.input.resource[resource] = _request.input.resource[resource];
            }
        }
        for (const arg of Object.keys(_request.input.args)) {
            if (target.input.args[arg] === undefined) {
                target.input.args[arg] = _request.input.args[arg];
            }
        }
        if (!_data || _data.jwt === undefined) {
            target.input.jwt = _request.input.jwt;
        }
        if (_data) {
            target.input.volatile = Object.assign({}, _request.input.volatile, _data.volatile);
        }
        else {
            target.input.volatile = _request.input.volatile;
        }
    }
    return target;
}
/**
 * Returns a currified function of pluginsManager.registerStrategy
 *
 * @param  {string} pluginName
 * @returns {function} function taking a strategy name and properties,
 *                    registering it into kuzzle, and returning
 *                    a promise
 */
function curryAddStrategy(pluginName) {
    return async function addStrategy(name, strategy) {
        // strategy constructors cannot be used directly to dynamically
        // add new strategies, because they cannot
        // be serialized and propagated to other cluster nodes
        // so if a strategy is not defined using an authenticator, we have
        // to reject the call
        if (!(0, safeObject_1.isPlainObject)(strategy) ||
            !(0, safeObject_1.isPlainObject)(strategy.config) ||
            typeof strategy.config.authenticator !== "string") {
            throw contextError.get("missing_authenticator", pluginName, name);
        }
        const mutex = new mutex_1.Mutex("auth:strategies:add", { ttl: 30000 });
        await mutex.lock();
        try {
            // @todo use Plugin.checkName to ensure format
            global.kuzzle.pluginsManager.registerStrategy(pluginName, name, strategy);
            return await global.kuzzle.pipe("core:auth:strategyAdded", {
                name,
                pluginName,
                strategy,
            });
        }
        finally {
            await mutex.unlock();
        }
    };
}
/**
 * Returns a currified function of pluginsManager.unregisterStrategy
 *
 * @param  {string} pluginName
 * @returns {function} function taking a strategy name and properties,
 *                    registering it into kuzzle, and returning
 *                    a promise
 */
function curryRemoveStrategy(pluginName) {
    // either async or catch unregisterStrategy exceptions + return a rejected
    // promise
    return async function removeStrategy(name) {
        const mutex = new mutex_1.Mutex("auth:strategies:remove", { ttl: 30000 });
        await mutex.lock();
        try {
            global.kuzzle.pluginsManager.unregisterStrategy(pluginName, name);
            return await global.kuzzle.pipe("core:auth:strategyRemoved", {
                name,
                pluginName,
            });
        }
        finally {
            await mutex.unlock();
        }
    };
}
//# sourceMappingURL=pluginContext.js.map