import "../types/Global";
/**
 * Mutex class options
 */
export interface MutexOptions {
    /**
     * Delay between 2 lock attempts (default: 200)
     */
    attemptDelay?: number;
    /**
     * Mutex lock acquisition timeout, in milliseconds (default: -1)
     *   If `-1`, will try to acquire the lock indefinitely.
     *   If `0`, locking will fail immediately if it cannot lock with its 1st attempt
     */
    timeout?: number;
    /**
     * Lock TTL in milliseconds (default: 5000)
     */
    ttl?: number;
}
/**
 * Mutex meant to work across a kuzzle cluster.
 *
 * Allow to have a process played on only 1 node, with the other ones waiting
 * until the lock is freed.
 * Also works within a single node: in that case, it's better
 * if lock attempts from different parts of the code use different Mutex
 * instances: each mutex will lock using a unique ID, and the lock can only
 * be freed by that mutex instance, and it alone.
 *
 * /!\ Meant to be used only with 1 independant redis client (single node or
 * cluster). Which is what Kuzzle supports today.
 * If, in the future, Kuzzle is able to support multiple independant
 * Redis servers, then this class needs to implement redlock to properly handle
 * synchronization between servers (see https://redis.io/topics/distlock)
 */
export declare class Mutex {
    readonly resource: string;
    readonly mutexId: string;
    readonly attemptDelay: number;
    readonly timeout: number;
    readonly ttl: number;
    private _locked;
    /**
     * @param {string} resource - resource identifier to be locked (must be identical across all nodes)
     * @param {Object} [options] - mutex options
     *    - `attemptDelay`: delay between 2 lock attempts (default: 200)
     *    - `timeout`: mutex lock acquisition timeout, in milliseconds (default: -1)
     *                 If -1, will try to acquire the lock indefinitely.
     *                 If 0, locking will fail immediately if it cannot lock with
     *                 its 1st attempt.
     *    - `ttl`: lock TTL in milliseconds (default: 5000)
     */
    constructor(resource: string, { attemptDelay, timeout, ttl }?: MutexOptions);
    /**
     * Locks the resource.
     * Resolves to a boolean telling whether the lock could be acquired before
     * the timeout or not.
     *
     * @return {Promise.<boolean>}
     */
    lock(): Promise<boolean>;
    /**
     * Unlock the mutex
     *
     * @return {Promise}
     */
    unlock(): Promise<void>;
    /**
     * Wait for the resource to be unlocked.
     * Return true if it waited until the unlocking
     * and false if it waited until the timeout
     *
     * @param {Object} [Options] - mutex options
     *    - `attemptDelay`: delay between 2 resource check (default: `this.attemptDelay`)
     *    - `timeout`: mutex wait acquisition timeout, in milliseconds (default: `this.timeout`)
     *                 If -1, will try to acquire the lock indefinitely.
     *                 If 0, locking will fail immediately if it cannot lock with
     *                 its 1st attempt.
     *
     * @return {Promise.<boolean>} True if the ressource has been unlocked before the `timeout`
     */
    wait({ attemptDelay, timeout, }: {
        attemptDelay?: number;
        timeout?: number;
    }): Promise<boolean>;
    get locked(): boolean;
}
