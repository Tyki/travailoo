import { Kuzzle } from "../../Kuzzle";
import { ArgsDocumentControllerCreate, ArgsDocumentControllerCreateOrReplace, ArgsDocumentControllerReplace, ArgsDocumentControllerUpdate, DocumentController } from "../../controllers/Document";
import { KDocumentContentGeneric, KDocument } from "../../types";
/**
 * Overload of the document controller.
 *
 * This class replace the following methods and will execute them by batch using
 * m* actions:
 *  - create => mCreate
 *  - replace => mReplace
 *  - createOrReplace => mCreateOrReplace
 *  - update => mUpdate
 *  - get => mGet
 *  - exists => mGet
 *  - delete => mDelete
 *
 * This will significantly increase performances.
 * The drawback is that standard API errors will not be available. (Except for the `services.storage.not_found` error).
 *
 * The m* actions returns the successes in the same order as in the request so
 * since we have the index of the single document inside the array of documents
 * sent to the action, we can retrieve the corresponding result in the array of
 * results.
 *
 */
export declare class BatchController extends DocumentController {
    private writer;
    /**
     * @param sdk Connected SDK
     * @param options.interval Timer interval in ms (10). Actions will be executed every {interval} ms
     * @param options.maxWriteBufferSize Max write buffer size (200). (Should match "limits.documentsWriteCount")
     * @param options.maxReadBufferSize Max read buffer size. (Should match "limits.documentsReadCount")
     */
    constructor(sdk: Kuzzle, { interval, maxWriteBufferSize, maxReadBufferSize }?: {
        interval?: number;
        maxWriteBufferSize?: number;
        maxReadBufferSize?: number;
    });
    /**
     * Dispose the instance.
     *
     * This method has to be called to destroy the underlaying timer sending batch requests.
     */
    dispose(): Promise<void>;
    /**
     * See sdk.document.create method
     *
     * @param index Index name
     * @param collection Collection name
     * @param content Document content
     * @param _id Optional document ID
     * @param options.queuable If true, queues the request during downtime, until connected to Kuzzle again
     * @param options.refresh If set to `wait_for`, Kuzzle will not respond until the API key is indexed
     * @param options.silent If true, then Kuzzle will not generate notifications
     * @param options.timeout Request Timeout in ms, after the delay if not resolved the promise will be rejected
     *
     * @returns The created document
     */
    create<TKDocumentContent extends KDocumentContentGeneric>(index: string, collection: string, content: Partial<TKDocumentContent>, _id?: string, options?: ArgsDocumentControllerCreate): Promise<KDocument<TKDocumentContent>>;
    /**
     * See document.replace method
     *
     * @param index Index name
     * @param collection Collection name
     * @param id Document ID
     * @param content Document content
     * @param options.queuable If true, queues the request during downtime, until connected to Kuzzle again
     * @param options.refresh If set to `wait_for`, Kuzzle will not respond until the API key is indexed
     * @param options.silent If true, then Kuzzle will not generate notifications
     * @param options.timeout Request Timeout in ms, after the delay if not resolved the promise will be rejected
     *
     * @returns The replaced document
     */
    replace<TKDocumentContent extends KDocumentContentGeneric>(index: string, collection: string, _id: string, content: Partial<TKDocumentContent>, options?: ArgsDocumentControllerReplace): Promise<KDocument<TKDocumentContent>>;
    /**
     * See document.createOrReplace method
     * @param index Index name
     * @param collection Collection name
     * @param id Document ID
     * @param content Document content
     * @param options.queuable If true, queues the request during downtime, until connected to Kuzzle again
     * @param options.refresh If set to `wait_for`, Kuzzle will not respond until the API key is indexed
     * @param options.silent If true, then Kuzzle will not generate notifications
     * @param options.timeout Request Timeout in ms, after the delay if not resolved the promise will be rejected
     *
     * @returns The created or replaced document
     */
    createOrReplace<TKDocumentContent extends KDocumentContentGeneric>(index: string, collection: string, _id: string, content: Partial<TKDocumentContent>, options?: ArgsDocumentControllerCreateOrReplace): Promise<KDocument<TKDocumentContent>>;
    /**
     * See document.update method
     *
     * @param index Index name
     * @param collection Collection name
     * @param id Document ID
     * @param content Document content
     * @param options.queuable If true, queues the request during downtime, until connected to Kuzzle again
     * @param options.refresh If set to `wait_for`, Kuzzle will not respond until the API key is indexed
     * @param options.silent If true, then Kuzzle will not generate notifications
     * @param options.retryOnConflict Number of times the database layer should retry in case of version conflict
     * @param options.source If true, returns the updated document inside the response
     * @param options.timeout Request Timeout in ms, after the delay if not resolved the promise will be rejected
     *
     * @returns The replaced document
     */
    update<TKDocumentContent extends KDocumentContentGeneric>(index: string, collection: string, _id: string, content: Partial<TKDocumentContent>, options?: ArgsDocumentControllerUpdate): Promise<KDocument<TKDocumentContent>>;
    /**
     * See document.get method
     *
     * @param index Index name
     * @param collection Collection name
     * @param _id Document ID
     * @param options Additional options
     * @param options.queuable If true, queues the request during downtime, until connected to Kuzzle again
     * @param options.refresh If set to `wait_for`, Kuzzle will not respond until the API key is indexed
     * @param options.silent If true, then Kuzzle will not generate notifications
     * @param options.timeout Request Timeout in ms, after the delay if not resolved the promise will be rejected
     *
     * @returns The document
     */
    get<TKDocumentContent extends KDocumentContentGeneric>(index: string, collection: string, id: string): Promise<KDocument<TKDocumentContent>>;
    /**
     * See document.exists method
     *
     * @param index Index name
     * @param collection Collection name
     * @param _id Document ID
     * @param options Additional options
     * @param options.queuable If true, queues the request during downtime, until connected to Kuzzle again
     * @param options.refresh If set to `wait_for`, Kuzzle will not respond until the API key is indexed
     * @param options.silent If true, then Kuzzle will not generate notifications
     * @param options.timeout Request Timeout in ms, after the delay if not resolved the promise will be rejected
     *
     * @returns True if the document exists
     */
    exists(index: string, collection: string, id: string): Promise<boolean>;
    /**
     * See document.delete method
     *
     * @param index Index name
     * @param collection Collection name
     * @param _id Document ID
     * @param options Additional options
     * @param options.queuable If true, queues the request during downtime, until connected to Kuzzle again
     * @param options.refresh If set to `wait_for`, Kuzzle will not respond until the API key is indexed
     * @param options.silent If true, then Kuzzle will not generate notifications
     * @param options.timeout Request Timeout in ms, after the delay if not resolved the promise will be rejected
     *
     * @returns The document ID
     */
    delete(index: string, collection: string, id: string): Promise<string>;
    /**
     * Used in function tests.
     * @internal
     */
    private createWriter;
}
