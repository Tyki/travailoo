"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DocumentController = void 0;
const Base_1 = require("./Base");
const Document_1 = require("../core/searchResult/Document");
class DocumentController extends Base_1.BaseController {
    constructor(kuzzle) {
        super(kuzzle, "document");
    }
    /**
     * Counts documents in a collection.
     *
     * A query can be provided to alter the count result,
     * otherwise returns the total number of documents in the collection.
     *
     * @see https://docs.kuzzle.io/sdk/js/7/controllers/document/count/
     *
     * @param index Index name
     * @param collection Collection name
     * @param query Query to match
     * @param options Additional options
     *    - `queuable` If true, queues the request during downtime, until connected to Kuzzle again
     *    - `timeout` Request Timeout in ms, after the delay if not resolved the promise will be rejected
     *
     * @returns The number of matching documents
     */
    count(index, collection, body, options = {}) {
        const request = {
            action: "count",
            body,
            collection,
            index,
        };
        return this.query(request, options).then((response) => response.result.count);
    }
    /**
     * Creates a new document in the persistent data storage.
     *
     * @see https://docs.kuzzle.io/sdk/js/7/controllers/document/create/
     *
     * @param index Index name
     * @param collection Collection name
     * @param content Document content
     * @param _id Optional document ID
     * @param options.queuable If true, queues the request during downtime, until connected to Kuzzle again
     * @param options.refresh If set to `wait_for`, Kuzzle will not respond until the API key is indexed
     * @param options.silent If true, then Kuzzle will not generate notifications
     * @param options.timeout Request Timeout in ms, after the delay if not resolved the promise will be rejected
     *
     * @returns The created document
     */
    create(index, collection, content, _id = null, options = {}) {
        const request = {
            _id,
            action: "create",
            body: content,
            collection,
            index,
            silent: options.silent,
        };
        return this.query(request, options).then((response) => response.result);
    }
    /**
     * Creates a new document in the persistent data storage,
     * or replaces its content if it already exists.
     *
     * @see https://docs.kuzzle.io/sdk/js/7/controllers/document/create-or-replace/
     *
     * @param index Index name
     * @param collection Collection name
     * @param id Document ID
     * @param content Document content
     * @param options.queuable If true, queues the request during downtime, until connected to Kuzzle again
     * @param options.refresh If set to `wait_for`, Kuzzle will not respond until the API key is indexed
     * @param options.silent If true, then Kuzzle will not generate notifications
     * @param options.timeout Request Timeout in ms, after the delay if not resolved the promise will be rejected
     *
     * @returns The created or replaced document
     */
    createOrReplace(index, collection, _id, content, options = {}) {
        const request = {
            _id,
            action: "createOrReplace",
            body: content,
            collection,
            index,
            silent: options.silent,
        };
        return this.query(request, options).then((response) => response.result);
    }
    /**
     * Deletes a document.
     *
     * @see https://docs.kuzzle.io/sdk/js/7/controllers/document/delete/
     *
     * @param index Index name
     * @param collection Collection name
     * @param _id Document ID
     * @param options Additional options
     * @param options.queuable If true, queues the request during downtime, until connected to Kuzzle again
     * @param options.refresh If set to `wait_for`, Kuzzle will not respond until the API key is indexed
     * @param options.silent If true, then Kuzzle will not generate notifications
     * @param options.timeout Request Timeout in ms, after the delay if not resolved the promise will be rejected
     *
     * @returns The document ID
     */
    delete(index, collection, _id, options = {}) {
        const request = {
            _id,
            action: "delete",
            collection,
            index,
            silent: options.silent,
        };
        return this.query(request, options).then((response) => response.result._id);
    }
    /**
     * Deletes documents matching the provided search query.
     *
     * @see https://docs.kuzzle.io/sdk/js/7/controllers/document/delete-by-query/
     *
     * @param index Index name
     * @param collection Collection name
     * @param query Query to match
     * @param options Additional options
     *    - `queuable` If true, queues the request during downtime, until connected to Kuzzle again
     *    - `refresh` If set to `wait_for`, Kuzzle will not respond until the API key is indexed
     *    - `silent` If true, then Kuzzle will not generate notifications
     *    - `lang` Query syntax. Can be 'elasticsearch' or 'koncorde'
     *    - `timeout` Request Timeout in ms, after the delay if not resolved the promise will be rejected
     *
     * @returns The deleted documents IDs
     */
    deleteByQuery(index, collection, query = {}, options = {}) {
        const request = {
            action: "deleteByQuery",
            body: query,
            collection,
            index,
            lang: options.lang,
            silent: options.silent,
        };
        return this.query(request, options).then((response) => response.result.ids);
    }
    /**
     * Deletes fields of an existing document.
     *
     * @see https://docs.kuzzle.io/core/2/api/controllers/document/delete-fields/
     *
     * @param index Index name
     * @param collection Collection name
     * @param _id Document ID
     * @param options Additional options
     *    - `queuable` If true, queues the request during downtime, until connected to Kuzzle again
     *    - `refresh` If set to `wait_for`, Kuzzle will not respond until the API key is indexed
     *    - `silent` If true, then Kuzzle will not generate notifications
     *    - `source` If true, the response will contain the updated document
     *    - `timeout` Request Timeout in ms, after the delay if not resolved the promise will be rejected
     *
     * @returns The updated document
     */
    deleteFields(index, collection, _id, fields, options = {}) {
        const request = {
            _id,
            action: "deleteFields",
            body: { fields },
            collection,
            index,
            silent: options.silent,
            source: options.source,
        };
        return this.query(request, options).then((response) => response.result);
    }
    /**
     * Checks if the given document exists.
     *
     * @see https://docs.kuzzle.io/sdk/js/7/controllers/document/exists/
     *
     * @param index Index name
     * @param collection Collection name
     * @param _id Document ID
     * @param options Additional options
     * @param options.queuable If true, queues the request during downtime, until connected to Kuzzle again
     * @param options.refresh If set to `wait_for`, Kuzzle will not respond until the API key is indexed
     * @param options.silent If true, then Kuzzle will not generate notifications
     * @param options.timeout Request Timeout in ms, after the delay if not resolved the promise will be rejected
     *
     * @returns True if the document exists
     */
    exists(index, collection, _id, options = {}) {
        const request = {
            _id,
            action: "exists",
            collection,
            index,
        };
        return this.query(request, options).then((response) => response.result);
    }
    /**
     * Gets a document.
     *
     * @see https://docs.kuzzle.io/sdk/js/7/controllers/document/get/
     *
     * @param index Index name
     * @param collection Collection name
     * @param _id Document ID
     * @param options Additional options
     * @param options.queuable If true, queues the request during downtime, until connected to Kuzzle again
     * @param options.refresh If set to `wait_for`, Kuzzle will not respond until the API key is indexed
     * @param options.silent If true, then Kuzzle will not generate notifications
     * @param options.timeout Request Timeout in ms, after the delay if not resolved the promise will be rejected
     *
     * @returns The document
     */
    get(index, collection, _id, options = {}) {
        const request = {
            _id,
            action: "get",
            collection,
            index,
        };
        return this.query(request, options).then((response) => response.result);
    }
    /**
     * Creates multiple documents.
     *
     * @see https://docs.kuzzle.io/sdk/js/7/controllers/document/m-create/
     *
     * @param index Index name
     * @param collection Collection name
     * @param documents Documents to create
     * @param options Additional options
     *    - `queuable` If true, queues the request during downtime, until connected to Kuzzle again
     *    - `refresh` If set to `wait_for`, Kuzzle will not respond until the API key is indexed
     *    - `silent` If true, then Kuzzle will not generate notifications
     *    - `timeout` Request Timeout in ms, after the delay if not resolved the promise will be rejected
     *    - `strict` If true, an error will occur if a document was not created
     *
     * @returns An object containing 2 arrays: "successes" and "errors"
     */
    mCreate(index, collection, documents, options = {}) {
        const request = {
            action: "mCreate",
            body: { documents },
            collection,
            index,
            silent: options.silent,
            strict: options.strict,
        };
        return this.query(request, options).then((response) => response.result);
    }
    /**
     * Creates or replaces multiple documents.
     *
     * @see https://docs.kuzzle.io/sdk/js/7/controllers/document/m-create-or-replace/
     *
     * @param index Index name
     * @param collection Collection name
     * @param documents Documents to create
     * @param options Additional options
     *    - `queuable` If true, queues the request during downtime, until connected to Kuzzle again
     *    - `refresh` If set to `wait_for`, Kuzzle will not respond until the API key is indexed
     *    - `silent` If true, then Kuzzle will not generate notifications
     *    - `timeout` Request Timeout in ms, after the delay if not resolved the promise will be rejected
     *    - `strict` If true, an error will occur if a document was not created
     *
     * @returns An object containing 2 arrays: "successes" and "errors"
     */
    mCreateOrReplace(index, collection, documents, options = {}) {
        const request = {
            action: "mCreateOrReplace",
            body: { documents },
            collection,
            index,
            silent: options.silent,
            strict: options.strict,
        };
        return this.query(request, options).then((response) => response.result);
    }
    /**
     * Deletes multiple documents.
     *
     * @see https://docs.kuzzle.io/sdk/js/7/controllers/document/m-delete/
     *
     * @param index Index name
     * @param collection Collection name
     * @param ids Document IDs
     * @param options Additional options
     *    - `queuable` If true, queues the request during downtime, until connected to Kuzzle again
     *    - `refresh` If set to `wait_for`, Kuzzle will not respond until the API key is indexed
     *    - `silent` If true, then Kuzzle will not generate notifications
     *    - `timeout` Request Timeout in ms, after the delay if not resolved the promise will be rejected
     *    - `strict` If true, an error will occur if a document was not deleted
     *
     * @returns An object containing 2 arrays: "successes" and "errors"
     */
    mDelete(index, collection, ids, options = {}) {
        const request = {
            action: "mDelete",
            body: { ids },
            collection,
            index,
            silent: options.silent,
            strict: options.strict,
        };
        return this.query(request, options).then((response) => response.result);
    }
    /**
     * Gets multiple documents.
     *
     * @see https://docs.kuzzle.io/sdk/js/7/controllers/document/m-get/
     *
     * @param index Index name
     * @param collection Collection name
     * @param ids Document IDs
     * @param options Additional options
     *    - `queuable` If true, queues the request during downtime, until connected to Kuzzle again
     *    - `verb` (HTTP only) Forces the verb of the route
     *    - `timeout` Request Timeout in ms, after the delay if not resolved the promise will be rejected
     *
     * @returns An object containing 2 arrays: "successes" and "errors"
     */
    mGet(index, collection, ids, options = {}) {
        const request = {
            action: "mGet",
            body: { ids },
            collection,
            index,
        };
        return this.query(request, options).then((response) => response.result);
    }
    /**
     * Replaces multiple documents.
     *
     * @see https://docs.kuzzle.io/sdk/js/7/controllers/document/m-replace/
     *
     * @param index Index name
     * @param collection Collection name
     * @param documents Documents to create
     * @param options Additional options
     *    - `queuable` If true, queues the request during downtime, until connected to Kuzzle again
     *    - `refresh` If set to `wait_for`, Kuzzle will not respond until the API key is indexed
     *    - `silent` If true, then Kuzzle will not generate notifications
     *    - `timeout` Request Timeout in ms, after the delay if not resolved the promise will be rejected
     *    - `strict` If true, an error will occur if a document was not replaced
     *
     * @returns An object containing 2 arrays: "successes" and "errors"
     */
    mReplace(index, collection, documents, options = {}) {
        const request = {
            action: "mReplace",
            body: { documents },
            collection,
            index,
            silent: options.silent,
            strict: options.strict,
        };
        return this.query(request, options).then((response) => response.result);
    }
    /**
     * Updates multiple documents.
     *
     * Conflicts may occur if the same document gets updated multiple times
     * within a short timespan in a database cluster. (See `retryOnConflict`)
     *
     * @see https://docs.kuzzle.io/sdk/js/7/controllers/document/m-update/
     *
     * @param index Index name
     * @param collection Collection name
     * @param documents Documents to create
     * @param options Additional options
     *    - `queuable` If true, queues the request during downtime, until connected to Kuzzle again
     *    - `refresh` If set to `wait_for`, Kuzzle will not respond until the API key is indexed
     *    - `silent` If true, then Kuzzle will not generate notifications
     *    - `retryOnConflict` Number of times the database layer should retry in case of version conflict
     *    - `timeout` Request Timeout in ms, after the delay if not resolved the promise will be rejected
     *    - `strict` If true, an error will occur if a document was not updated
     *
     * @returns An object containing 2 arrays: "successes" and "errors"
     */
    mUpdate(index, collection, documents, options = {}) {
        const request = {
            action: "mUpdate",
            body: { documents },
            collection,
            index,
            silent: options.silent,
            strict: options.strict,
        };
        return this.query(request, options).then((response) => response.result);
    }
    /**
     * Applies partial updates to multiple documents.
     *
     * If a document doesn't already exist, a new document is created.
     * @see https://docs.kuzzle.io/sdk/js/7/controllers/document/m-upsert/
     *
     * @param index Index name
     * @param collection Collection name
     * @param documents Documents to update
     * @param options Additional options
     *    - `queuable` If true, queues the request during downtime, until connected to Kuzzle again
     *    - `refresh` If set to `wait_for`, Kuzzle will not respond until the API key is indexed
     *    - `silent` If true, then Kuzzle will not generate notifications
     *    - `retryOnConflict` Number of times the database layer should retry in case of version conflict
     *    - `strict` If true, an error will occur if a document was not updated
     *
     * @returns An object containing 2 arrays: "successes" and "errors"
     */
    mUpsert(index, collection, documents, options = {}) {
        const request = {
            action: "mUpsert",
            body: { documents },
            collection,
            index,
            silent: options.silent,
            strict: options.strict,
        };
        return this.query(request, options).then((response) => response.result);
    }
    /**
     * Replaces the content of an existing document.
     *
     * @see https://docs.kuzzle.io/sdk/js/7/controllers/document/replace/
     *
     * @param index Index name
     * @param collection Collection name
     * @param id Document ID
     * @param content Document content
     * @param options.queuable If true, queues the request during downtime, until connected to Kuzzle again
     * @param options.refresh If set to `wait_for`, Kuzzle will not respond until the API key is indexed
     * @param options.silent If true, then Kuzzle will not generate notifications
     * @param options.timeout Request Timeout in ms, after the delay if not resolved the promise will be rejected
     *
     * @returns The replaced document
     */
    replace(index, collection, _id, content, options = {}) {
        const request = {
            _id,
            action: "replace",
            body: content,
            collection,
            index,
            silent: options.silent,
        };
        return this.query(request, options).then((response) => response.result);
    }
    /**
     * Searches documents.
     *
     * @see https://docs.kuzzle.io/sdk/js/7/controllers/document/search/
     *
     * @param index Index name
     * @param collection Collection name
     * @param searchBody Search query
     * @param options Additional options
     *    - `queuable` If true, queues the request during downtime, until connected to Kuzzle again
     *    - `from` Offset of the first document to fetch
     *    - `size` Maximum number of documents to retrieve per page
     *    - `scroll` When set, gets a forward-only cursor having its ttl set to the given value (e.g. `30s`)
     *    - `verb` (HTTP only) Forces the verb of the route
     *    - `timeout` Request Timeout in ms, after the delay if not resolved the promise will be rejected
     *
     * @returns A SearchResult
     */
    search(index, collection, searchBody = {}, options = {}) {
        return this._search(index, collection, searchBody, options).then(({ response, request, opts }) => new Document_1.DocumentSearchResult(this.kuzzle, request, opts, response.result));
    }
    _search(index, collection, body = {}, options = {}) {
        const request = {
            action: "search",
            body: null,
            collection,
            index,
        };
        if (this.kuzzle.protocol.name === "http" &&
            options.verb &&
            options.verb.toLowerCase() === "get") {
            request.searchBody = body;
        }
        else {
            request.body = body;
        }
        for (const opt of ["from", "size", "scroll", "lang"]) {
            request[opt] = options[opt];
        }
        const opts = { verb: options.verb || "POST", ...options };
        return this.query(request, opts).then((response) => ({
            opts,
            request,
            response,
        }));
    }
    /**
     * Updates the content of an existing document.
     *
     * @see https://docs.kuzzle.io/sdk/js/7/controllers/document/update/
     *
     * @param index Index name
     * @param collection Collection name
     * @param id Document ID
     * @param content Document content
     * @param options.queuable If true, queues the request during downtime, until connected to Kuzzle again
     * @param options.refresh If set to `wait_for`, Kuzzle will not respond until the API key is indexed
     * @param options.silent If true, then Kuzzle will not generate notifications
     * @param options.retryOnConflict Number of times the database layer should retry in case of version conflict
     * @param options.source If true, returns the updated document inside the response
     * @param options.timeout Request Timeout in ms, after the delay if not resolved the promise will be rejected
     *
     * @returns The replaced document
     */
    update(index, collection, _id, content, options = {}) {
        const request = {
            _id,
            action: "update",
            body: content,
            collection,
            index,
            retryOnConflict: options.retryOnConflict,
            silent: options.silent,
            source: options.source,
        };
        return this.query(request, options).then((response) => response.result);
    }
    /**
     * Updates documents matching the provided search query.
     *
     * @see https://docs.kuzzle.io/sdk/js/7/controllers/document/update-by-query/
     *
     * @param index Index name
     * @param collection Collection name
     * @param query Query to match
     * @param changes Partial changes to apply to the documents
     * @param options Additional options
     *    - `refresh` If set to `wait_for`, Kuzzle will not respond until the API key is indexed
     *    - `silent` If true, then Kuzzle will not generate notifications
     *    - `source` If true, returns the updated document inside the response
     *    - `lang` Query syntax. Can be 'elasticsearch' or 'koncorde'
     *    - `timeout` Request Timeout in ms, after the delay if not resolved the promise will be rejected
     *
     * @returns An object containing 2 arrays: "successes" and "errors"
     */
    updateByQuery(index, collection, query, changes, options = {}) {
        const request = {
            action: "updateByQuery",
            body: { changes, query },
            collection,
            index,
            lang: options.lang,
            silent: options.silent,
            source: options.source,
        };
        return this.query(request, options).then((response) => response.result);
    }
    /**
     * Applies a partial update to an existing document.
     * If the document doesn't already exist, a new document is created.
     * @see https://docs.kuzzle.io/sdk/js/7/controllers/document/upsert/
     *
     * @param index Index name
     * @param collection Collection name
     * @param _id Unique document identifier
     * @param changes Partial content of the document to update
     * @param [options]
     *    - `default` Fields to add to the document if it gets created
     *    - `refresh` If set to `wait_for`, Kuzzle will not respond until the API key is indexed
     *    - `silent` If true, then Kuzzle will not generate notifications
     *    - `retryOnConflict` Number of times the database layer should retry in case of version conflict
     *    - `source` If true, returns the updated document inside the response
     *
     * @returns Information about the updated document
     */
    upsert(index, collection, _id, changes, options = {}) {
        const request = {
            _id,
            action: "upsert",
            body: { changes, default: options.default },
            collection,
            index,
            silent: options.silent,
            source: options.source,
        };
        return this.query(request, options).then((response) => response.result);
    }
    /**
     * Validates a document against existing validation rules.
     *
     * @see https://docs.kuzzle.io/sdk/js/7/controllers/document/validate/
     *
     * @param index Index name
     * @param collection Collection name
     * @param content Document content
     * @param options Additional options
     *    - `queuable` If true, queues the request during downtime, until connected to Kuzzle again
     *    - `timeout` Request Timeout in ms, after the delay if not resolved the promise will be rejected
     *
     * @returns True if the document is valid
     */
    validate(index, collection, content, options = {}) {
        return this.query({
            action: "validate",
            body: content,
            collection,
            index,
        }, options).then((response) => response.result);
    }
}
exports.DocumentController = DocumentController;
//# sourceMappingURL=Document.js.map