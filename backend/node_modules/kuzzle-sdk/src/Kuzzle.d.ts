import { KuzzleEventEmitter, PrivateAndPublicSDKEvents, PublicKuzzleEvents } from "./core/KuzzleEventEmitter";
import { KuzzleAbstractProtocol } from "./protocols/abstract/Base";
import { AuthController } from "./controllers/Auth";
import { CollectionController } from "./controllers/Collection";
import { DocumentController } from "./controllers/Document";
import { IndexController } from "./controllers/Index";
import { RealtimeController } from "./controllers/Realtime";
import { ServerController } from "./controllers/Server";
import { SecurityController } from "./controllers/Security";
import { Deprecation } from "./utils/Deprecation";
import { BaseRequest, JSONObject, Notification } from "./types";
import { RequestPayload } from "./types/RequestPayload";
import { ResponsePayload } from "./types/ResponsePayload";
import { KuzzleError } from "./KuzzleError";
import { DisconnectionOrigin } from "./protocols/DisconnectionOrigin";
export declare class Kuzzle extends KuzzleEventEmitter {
    [key: string]: any;
    /**
     * Protocol used by the SDK to communicate with Kuzzle.
     */
    protocol: any;
    /**
     * If true, automatically renews all subscriptions on a reconnected event.
     */
    autoResubscribe: boolean;
    /**
     * Timeout before sending again a similar event.
     */
    eventTimeout: number;
    /**
     * SDK version.
     */
    sdkVersion: string;
    /**
     * SDK name (e.g: `js@7.4.2`).
     */
    sdkName: string;
    /**
     * Common volatile data that will be sent to all future requests.
     */
    volatile: JSONObject;
    /**
     * Handle deprecation warning in development mode (hidden in production)
     */
    deprecationHandler: Deprecation;
    /**
     * Authenticator function called after a reconnection if the SDK is no longer
     * authenticated.
     */
    authenticator: () => Promise<void>;
    /**
     * List of every events emitted by the SDK.
     */
    events: PublicKuzzleEvents[];
    auth: AuthController;
    bulk: any;
    collection: CollectionController;
    document: DocumentController;
    index: IndexController;
    ms: any;
    realtime: RealtimeController;
    security: SecurityController;
    server: ServerController;
    private _protectedEvents;
    private _offlineQueue;
    private _autoQueue;
    private _autoReplay;
    private _offlineQueueLoader;
    private _queuing;
    private _queueFilter;
    private _queueMaxSize;
    private _queueTTL;
    private _replayInterval;
    private _requestTimeout;
    private _tokenExpiredInterval;
    private _lastTokenExpired;
    private _cookieAuthentication;
    private _reconnectInProgress;
    private _loggedIn;
    private __proxy__;
    /**
     * Instantiate a new SDK
     *
     * @example
     *
     * import { Kuzzle, WebSocket } from 'kuzzle-sdk';
     *
     * const kuzzle = new Kuzzle(
     *   new WebSocket('localhost')
     * );
     */
    constructor(
    /**
     * Network protocol to connect to Kuzzle. (e.g. `Http` or `WebSocket`)
     */
    protocol: KuzzleAbstractProtocol, options?: {
        /**
         * Automatically renew all subscriptions on a `reconnected` event
         * Default: `true`
         */
        autoResubscribe?: boolean;
        /**
         * Time (in ms) during which a similar event is ignored
         * Default: `200`
         */
        eventTimeout?: number;
        /**
         * Common volatile data, will be sent to all future requests
         * Default: `{}`
         */
        volatile?: JSONObject;
        /**
         * If `true`, automatically queues all requests during offline mode
         * Default: `false`
         */
        autoQueue?: boolean;
        /**
         * If `true`, automatically replays queued requests
         * on a `reconnected` event
         * Default: `false`
         */
        autoReplay?: boolean;
        /**
         * Custom function called during offline mode to filter
         * queued requests on-the-fly
         */
        queueFilter?: (request: RequestPayload) => boolean;
        /**
         * Called before dequeuing requests after exiting offline mode,
         * to add items at the beginning of the offline queue
         */
        offlineQueueLoader?: (...any: any[]) => any;
        /**
         * Number of maximum requests kept during offline mode
         * Default: `500`
         */
        queueMaxSize?: number;
        /**
         * Time a queued request is kept during offline mode, in milliseconds
         * Default: `120000`
         */
        queueTTL?: number;
        /**
         * Delay between each replayed requests, in milliseconds
         * Default: `10`
         */
        replayInterval?: number;
        /**
         * Time (in ms) during which a request will still be waited to be resolved
         * Set it to `-1` if you want to wait indefinitely.
         * Default: `-1`
         */
        requestTimeout?: number;
        /**
         * Time (in ms) during which a TokenExpired event is ignored
         * Default: `1000`
         */
        tokenExpiredInterval?: number;
        /**
         * If set to `auto`, the `autoQueue` and `autoReplay` are also set to `true`
         */
        offlineMode?: "auto";
        /**
         * If `true` uses cookie to store token
         * Only supported in a browser
         * Default: `false`
         */
        cookieAuth?: boolean;
        /**
         * Show deprecation warning in development mode (hidden either way in production)
         * Default: `true`
         */
        deprecationWarning?: boolean;
    });
    /**
     * Returns `true` if the SDK holds a valid token
     */
    get authenticated(): boolean;
    get autoQueue(): any;
    set autoQueue(value: any);
    get autoReconnect(): boolean;
    set autoReconnect(value: boolean);
    get autoReplay(): any;
    set autoReplay(value: any);
    /**
     * Returns `true` if the SDK is using the cookie authentication mode.
     * (Web only)
     */
    get cookieAuthentication(): boolean;
    /**
     * Returns `true` if the SDK is currently connected to a Kuzzle server.
     */
    get connected(): any;
    get host(): any;
    get jwt(): any;
    set jwt(encodedJwt: any);
    get offlineQueue(): any;
    get offlineQueueLoader(): any;
    set offlineQueueLoader(value: any);
    get port(): any;
    get queueFilter(): any;
    set queueFilter(value: any);
    get queueMaxSize(): any;
    set queueMaxSize(value: any);
    get queueTTL(): any;
    set queueTTL(value: any);
    get reconnectionDelay(): number;
    get replayInterval(): any;
    set replayInterval(value: any);
    get requestTimeout(): number;
    set requestTimeout(value: number);
    get sslConnection(): any;
    get tokenExpiredInterval(): any;
    set tokenExpiredInterval(value: any);
    /**
     * Emit an event to all registered listeners
     * An event cannot be emitted multiple times before a timeout has been reached.
     */
    emit(eventName: PrivateAndPublicSDKEvents, ...payload: unknown[]): boolean;
    private _superEmit;
    on(eventName: "connected" | "reconnected" | "reAuthenticated" | "tokenExpired", listener: () => void): this;
    on(eventName: "logoutAttempt", listener: (status: {
        success: true;
    }) => void): this;
    on(eventName: "loginAttempt", listener: (data: {
        success: boolean;
        error: string;
    }) => void): this;
    on(eventName: "discarded", listener: (request: RequestPayload) => void): this;
    on(eventName: "disconnected", listener: (context: {
        origin: DisconnectionOrigin;
    }) => void): this;
    on(eventName: "networkError" | "reconnectionError", listener: (error: Error) => void): this;
    on(eventName: "offlineQueuePop", listener: (request: RequestPayload) => void): this;
    on(eventName: "offlineQueuePush", listener: (data: {
        request: RequestPayload;
    }) => void): this;
    on(eventName: "queryError", listener: (data: {
        error: KuzzleError;
        request: RequestPayload;
    }) => void): this;
    on(eventName: "callbackError", listener: (data: {
        error: KuzzleError;
        notification: Notification;
    }) => void): this;
    /**
     * Connects to a Kuzzle instance
     */
    connect(): Promise<void>;
    /**
     * Set this client to use a specific API key.
     *
     * After doing this you don't need to use login as it bypasses the authentication process.
     */
    setAPIKey(apiKey: string): void;
    _reconnect(): Promise<void>;
    /**
     * Try to re-authenticate the SDK if the current token is invalid.
     *
     * If the token is invalid, this method will return false and emit a
     * "reconnectionError" event when:
     *   - the SDK cannot re-authenticate using the authenticator function
     *   - the authenticator function is not set
     *
     * This method never returns a rejected promise.
     */
    private tryReAuthenticate;
    /**
     * Use the "authenticator" function to authenticate the SDK.
     *
     * @returns The authentication token
     */
    authenticate(): Promise<void>;
    /**
     * Check wether the user is authenticated or not
     * by verifiying if a token is present and still valid
     * and if the token doesn't belong to the anonymous user.
     */
    isAuthenticated(): Promise<boolean>;
    /**
     * Adds a listener to a Kuzzle global event. When an event is fired, listeners are called in the order of their
     * insertion.
     *
     * @param {string} event - name of the global event to subscribe to
     * @param {function} listener - callback to invoke each time an event is fired
     */
    addListener(event: any, listener: any): this;
    private _superAddListener;
    /**
     * Empties the offline queue without replaying it.
     *
     * @returns {Kuzzle}
     */
    flushQueue(): this;
    /**
     * Disconnects from Kuzzle and invalidate this instance.
     */
    disconnect(): void;
    /**
     * This is a low-level method, exposed to allow advanced SDK users to bypass
     * high-level methods.
     * Base method used to send read queries to Kuzzle
     *
     * Takes an optional argument object with the following properties:
     *    - volatile (object, default: null):
     *        Additional information passed to notifications to other users
     *
     * @param req
     * @param opts - Optional arguments
     */
    query<TRequest extends BaseRequest = BaseRequest, TResult = JSONObject>(req: TRequest, opts?: JSONObject): Promise<ResponsePayload<TResult>>;
    /**
     * Starts the requests queuing.
     */
    startQueuing(): this;
    /**
     * Stops the requests queuing.
     */
    stopQueuing(): this;
    /**
     * Plays the requests queued during offline mode.
     */
    playQueue(): this;
    /**
     * On token expiration, reset jwt and unsubscribe all rooms.
     * Throttles to avoid duplicate event triggers.
     */
    tokenExpired(): Promise<void>;
    /**
     * Adds a new controller and make it available in the SDK.
     *
     * @param ControllerClass
     * @param accessor
     */
    useController(ControllerClass: any, accessor: string): this;
    private _checkPropertyType;
    /**
     * Clean up the queue, ensuring the queryTTL and queryMaxSize properties are respected
     */
    private _cleanQueue;
    /**
     * Play all queued requests, in order.
     */
    private _dequeue;
    /**
     * Sends a request with a timeout
     *
     * @param delay Delay before the request is rejected if not resolved
     * @param request Request object
     * @param options Request options
     * @returns Resolved request or a TimedOutError
     */
    private _timeoutRequest;
}
